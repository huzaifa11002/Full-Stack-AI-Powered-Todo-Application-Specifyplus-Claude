# Data Model: OpenAI ChatKit Frontend

**Feature**: 002-chatkit-frontend
**Date**: 2026-01-14
**Phase**: Phase 1 - Design & Contracts

## Overview

This document defines the frontend data structures for the OpenAI ChatKit chat interface. All data structures are TypeScript interfaces that represent the shape of data flowing through the application. The backend database schema is already defined in feature 001-mcp-ai-chat.

---

## Frontend Data Structures

### Message Entity

Represents a single message in a conversation (user or assistant).

```typescript
interface Message {
  id?: string;                    // Optional: client-generated UUID for optimistic updates
  role: 'user' | 'assistant';     // Message sender role
  content: string;                // Message text content
  tool_calls?: ToolCall[];        // Optional: AI tool invocations (assistant messages only)
  created_at?: string;            // ISO 8601 timestamp (e.g., "2026-01-14T19:30:00Z")
}
```

**Field Descriptions**:
- `id`: Optional client-side identifier for optimistic updates. Not sent to backend.
- `role`: Either "user" (human) or "assistant" (AI). No system messages in MVP.
- `content`: Plain text message content. Max 2000 characters (validated on input).
- `tool_calls`: Array of tool invocations. Only present in assistant messages when AI uses tools.
- `created_at`: Timestamp when message was created. Generated by backend, displayed by frontend.

**Validation Rules**:
- `role`: Must be exactly "user" or "assistant"
- `content`: 1-2000 characters, cannot be whitespace-only
- `tool_calls`: Optional array, only valid for assistant messages
- `created_at`: Must be valid ISO 8601 format if present

**State Transitions**:
- User message: Created client-side → sent to backend → confirmed with backend timestamp
- Assistant message: Received from backend → added to message list → displayed

**Example**:
```typescript
// User message
{
  id: "temp-123",
  role: "user",
  content: "Add a task to buy groceries",
  created_at: "2026-01-14T19:30:00Z"
}

// Assistant message with tool call
{
  role: "assistant",
  content: "I've added 'Buy groceries' to your task list.",
  tool_calls: [{
    tool: "add_task",
    params: { title: "Buy groceries" },
    result: { id: 5, status: "created" }
  }],
  created_at: "2026-01-14T19:30:05Z"
}
```

---

### ToolCall Entity

Represents an AI agent tool invocation within an assistant message.

```typescript
interface ToolCall {
  tool: string;                   // Tool name (e.g., "add_task", "list_tasks")
  params: Record<string, any>;    // Tool parameters as key-value pairs
  result: Record<string, any>;    // Tool execution result as key-value pairs
}
```

**Field Descriptions**:
- `tool`: Name of the MCP tool invoked by the AI agent
- `params`: Parameters passed to the tool (varies by tool)
- `result`: Result returned by the tool (varies by tool)

**Tool Types**:
- `add_task`: Create new task
- `list_tasks`: Retrieve task list
- `complete_task`: Mark task as complete
- `delete_task`: Remove task
- `update_task`: Modify task details

**Validation Rules**:
- `tool`: Must be one of the supported tool names
- `params`: Must be valid JSON object
- `result`: Must be valid JSON object

**Example Tool Calls**:
```typescript
// Add task
{
  tool: "add_task",
  params: {
    user_id: 1,
    title: "Buy groceries",
    description: "Milk, eggs, bread"
  },
  result: {
    id: 5,
    title: "Buy groceries",
    is_completed: false,
    created_at: "2026-01-14T19:30:05Z"
  }
}

// List tasks
{
  tool: "list_tasks",
  params: {
    user_id: 1,
    is_completed: false
  },
  result: {
    tasks: [
      { id: 1, title: "Task 1", is_completed: false },
      { id: 2, title: "Task 2", is_completed: false }
    ],
    count: 2
  }
}

// Complete task
{
  tool: "complete_task",
  params: {
    user_id: 1,
    task_id: 3
  },
  result: {
    id: 3,
    title: "Task 3",
    is_completed: true,
    updated_at: "2026-01-14T19:30:10Z"
  }
}
```

---

### Conversation Entity

Represents a chat session between user and AI assistant.

```typescript
interface Conversation {
  id: number;                     // Backend-generated conversation ID
  created_at: string;             // ISO 8601 timestamp
  updated_at: string;             // ISO 8601 timestamp
  preview?: string;               // Optional: first message or summary for display
}
```

**Field Descriptions**:
- `id`: Unique identifier assigned by backend
- `created_at`: Timestamp when conversation was created
- `updated_at`: Timestamp when conversation was last updated (new message added)
- `preview`: Optional preview text for conversation list (first message or summary)

**Validation Rules**:
- `id`: Positive integer
- `created_at`: Valid ISO 8601 timestamp
- `updated_at`: Valid ISO 8601 timestamp, >= created_at
- `preview`: Optional string, max 100 characters

**State Transitions**:
- New conversation: Created when user sends first message without conversation_id
- Active conversation: Updated when new messages are added
- Resumed conversation: Loaded from backend when user returns to chat

**Example**:
```typescript
{
  id: 42,
  created_at: "2026-01-14T19:00:00Z",
  updated_at: "2026-01-14T19:30:00Z",
  preview: "Add a task to buy groceries"
}
```

---

### ChatState Entity

Represents the current state of the chat interface (managed by useChat hook).

```typescript
interface ChatState {
  messages: Message[];                    // Current conversation messages
  currentConversationId: number | null;   // Active conversation ID (null for new)
  isLoading: boolean;                     // API request in progress
  error: string | null;                   // Error message if any
}
```

**Field Descriptions**:
- `messages`: Array of messages in current conversation (chronological order)
- `currentConversationId`: ID of active conversation, null for new conversation
- `isLoading`: True when waiting for API response, false otherwise
- `error`: Error message string if request failed, null otherwise

**State Transitions**:
```
Initial State:
  messages: []
  currentConversationId: null
  isLoading: false
  error: null

User Sends Message:
  messages: [...messages, userMessage]  // Optimistic update
  isLoading: true
  error: null

API Success:
  messages: [...messages, assistantMessage]
  currentConversationId: <id>  // Set if was null
  isLoading: false
  error: null

API Failure:
  messages: [...messages] (remove optimistic message)
  isLoading: false
  error: "Failed to send message"

New Conversation:
  messages: []
  currentConversationId: null
  isLoading: false
  error: null
```

**Example**:
```typescript
// Active conversation with messages
{
  messages: [
    { role: "user", content: "Add task", created_at: "..." },
    { role: "assistant", content: "Task added", tool_calls: [...], created_at: "..." }
  ],
  currentConversationId: 42,
  isLoading: false,
  error: null
}

// Loading state
{
  messages: [...],
  currentConversationId: 42,
  isLoading: true,
  error: null
}

// Error state
{
  messages: [...],
  currentConversationId: 42,
  isLoading: false,
  error: "Network error. Please try again."
}
```

---

### ChatRequest Entity

Represents a request to send a message to the backend API.

```typescript
interface ChatRequest {
  conversation_id?: number;       // Optional: null for new conversation
  message: string;                // User message (1-2000 chars)
}
```

**Field Descriptions**:
- `conversation_id`: Optional conversation ID to continue existing conversation
- `message`: User's message text

**Validation Rules**:
- `conversation_id`: Optional positive integer or undefined
- `message`: 1-2000 characters, cannot be whitespace-only

**Example**:
```typescript
// New conversation
{
  message: "Add a task to buy groceries"
}

// Continue existing conversation
{
  conversation_id: 42,
  message: "Mark task 3 as complete"
}
```

---

### ChatResponse Entity

Represents a response from the backend API after sending a message.

```typescript
interface ChatResponse {
  conversation_id: number;        // Conversation ID (new or existing)
  response: string;               // AI assistant's response message
  tool_calls: ToolCall[];         // Tools invoked by AI (empty array if none)
}
```

**Field Descriptions**:
- `conversation_id`: ID of the conversation (newly created or existing)
- `response`: AI assistant's text response
- `tool_calls`: Array of tool invocations (empty if no tools used)

**Validation Rules**:
- `conversation_id`: Positive integer
- `response`: Non-empty string
- `tool_calls`: Array of ToolCall objects (can be empty)

**Example**:
```typescript
// Response with tool call
{
  conversation_id: 42,
  response: "I've added 'Buy groceries' to your task list.",
  tool_calls: [
    {
      tool: "add_task",
      params: { user_id: 1, title: "Buy groceries" },
      result: { id: 5, status: "created" }
    }
  ]
}

// Response without tool call
{
  conversation_id: 42,
  response: "I can help you manage your tasks. What would you like to do?",
  tool_calls: []
}
```

---

## Data Flow Diagrams

### Message Send Flow

```
User Input
    ↓
ChatInput Component
    ↓
useChat Hook (sendMessage)
    ↓
Optimistic Update (add user message to state)
    ↓
API Client (POST /api/{user_id}/chat)
    ↓
Backend Processing
    ↓
ChatResponse
    ↓
useChat Hook (update state)
    ↓
Add assistant message to state
    ↓
ChatInterface Component (re-render)
    ↓
Display new messages
```

### Conversation Persistence Flow

```
Page Load
    ↓
Check localStorage for conversation_id
    ↓
If conversation_id exists:
    ↓
    Load conversation history from backend (optional)
    ↓
    Initialize useChat with conversation_id
    ↓
If no conversation_id:
    ↓
    Initialize useChat with null
    ↓
    Show empty state
```

### Tool Call Visualization Flow

```
ChatResponse received
    ↓
Extract tool_calls array
    ↓
For each tool call:
    ↓
    Map tool name to icon
    ↓
    Map tool name to label
    ↓
    Format parameters
    ↓
    Format result
    ↓
    Render ToolCallDisplay component
    ↓
Display inline with assistant message
```

---

## Persistence Strategy

### localStorage

**Stored Data**:
- `chatkit_conversation_id`: Current conversation ID (number or null)

**Purpose**: Resume conversation after page refresh

**Implementation**:
```typescript
// Save conversation ID
localStorage.setItem('chatkit_conversation_id', conversationId.toString());

// Load conversation ID
const savedId = localStorage.getItem('chatkit_conversation_id');
const conversationId = savedId ? parseInt(savedId, 10) : null;

// Clear conversation ID (new conversation)
localStorage.removeItem('chatkit_conversation_id');
```

### React State

**Stored Data**:
- Messages array (current conversation)
- Loading state
- Error state

**Purpose**: Fast access during active session

**Lifecycle**:
- Initialized on component mount
- Updated on user actions and API responses
- Cleared on new conversation
- Lost on page refresh (re-fetched from backend)

### Backend Database

**Stored Data** (reference only - already implemented):
- Conversations table (id, user_id, created_at, updated_at)
- Messages table (id, conversation_id, role, content, tool_calls, created_at)

**Purpose**: Source of truth for all conversation data

**Access Pattern**:
- Write: Every message sent (user and assistant)
- Read: On page load (optional - fetch conversation history)
- Update: Conversation updated_at on new messages

---

## Type Safety

### TypeScript Configuration

All interfaces must be exported from `types/chat.ts`:

```typescript
// types/chat.ts
export interface Message { /* ... */ }
export interface ToolCall { /* ... */ }
export interface Conversation { /* ... */ }
export interface ChatState { /* ... */ }
export interface ChatRequest { /* ... */ }
export interface ChatResponse { /* ... */ }
```

### Import Pattern

```typescript
// In components
import { Message, ToolCall } from '@/types/chat';

// In hooks
import { ChatState, ChatRequest, ChatResponse } from '@/types/chat';

// In API client
import { ChatRequest, ChatResponse } from '@/types/chat';
```

### Validation

**Client-side Validation**:
- Message length (1-2000 chars)
- Whitespace-only check
- Conversation ID format (positive integer)

**Backend Validation** (reference):
- Pydantic models validate all requests
- Database constraints enforce data integrity
- JWT authentication validates user identity

---

## Performance Considerations

### Message List Optimization

**Current Approach** (MVP):
- Render all messages in array
- Suitable for conversations up to 100 messages

**Future Optimization** (if needed):
- Virtual scrolling (react-window or react-virtualized)
- Pagination (load older messages on scroll up)
- Message grouping by date

### State Update Optimization

**Optimistic Updates**:
- Add user message immediately (no wait for API)
- Better perceived performance
- Rollback on error

**Batching**:
- React automatically batches state updates
- Multiple setState calls in same event handler are batched

### Re-render Optimization

**Memoization**:
- Use `React.memo` for ChatMessage component
- Use `useMemo` for expensive computations
- Use `useCallback` for event handlers

**Example**:
```typescript
const ChatMessage = React.memo(({ message }: ChatMessageProps) => {
  // Component only re-renders if message changes
  return <div>{message.content}</div>;
});
```

---

## Error Handling

### Error Types

**Network Errors**:
- Offline (no internet connection)
- Timeout (request takes too long)
- Server unavailable (5xx errors)

**Authentication Errors**:
- 401 Unauthorized (invalid/expired JWT)
- Redirect to login page

**Validation Errors**:
- 400 Bad Request (invalid message format)
- Display error message to user

**Application Errors**:
- Empty response from backend
- Invalid JSON in response
- Missing required fields

### Error State Management

```typescript
interface ErrorState {
  message: string;      // User-friendly error message
  code?: string;        // Error code for debugging
  retryable: boolean;   // Can user retry the action?
}
```

### Error Recovery

**Retry Strategy**:
- User can manually retry failed messages
- Automatic retry for transient errors (optional)
- Exponential backoff for repeated failures

**User Feedback**:
- Toast notifications for errors
- Inline error messages in chat
- Retry button for failed messages

---

## Next Steps

1. ✅ Data model defined
2. ⏭️ Create contracts/ (API contracts and TypeScript types)
3. ⏭️ Create quickstart.md (setup and usage guide)
4. ⏭️ Update agent context (CLAUDE.md)
5. ⏭️ Generate implementation tasks (/sp.tasks)

**Data Model Status**: Complete
**Ready for Contracts Phase**: Yes
